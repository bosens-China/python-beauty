# 名字的力量：变量与引用

> **“What's in a name? That which we call a rose By any other name would smell as sweet.”**  
> **“名字代表什么？我们所称的玫瑰，换个名字还是一样芳香。”**  
> — _威廉·莎士比亚，《罗密欧与朱丽叶》_

---

在编程的创世纪里，变量通常被比喻为“盒子”。

在 C 或 Java 的世界中，当你声明 `int a = 10` 时，你实际上是在内存中申请了一个特定大小的盒子，给它贴上标签 `a`，然后把数字 `10` 放了进去。如果你稍后写 `a = 20`，你是把 `10` 拿出来，把 `20` 放进去。盒子始终在那里，没动过。

**但在 Python 的世界里，这个比喻是完全错误的。**

如果你带着“盒子”的思维来写 Python，你迟早会被那些莫名其妙被修改的数据吓出一身冷汗。

在 Python 中，变量不是盒子，而是**便利贴（Post-it Note）**。

## 名字与对象：便利贴与气球

让我们重写那个简单的赋值语句：

```python
a = 10
```

在 Python 解释器眼中，这行代码发生了两件事：

1. **创建对象**：在内存的某个角落，吹起了一个气球（对象），气球上写着数字 `10`。
2. **贴上标签**：拿一张写着 `a` 的便利贴，贴到了这个气球上。

当我们执行 `a = 20` 时，发生了什么？  
解释器**并没有**擦掉气球上的 `10` 改成 `20`。  
它是吹起了一个**新的气球**，上面写着 `20`，然后把便利贴 `a` 从 `10` 号气球上撕下来，贴到了 `20` 号气球上。

原来的 `10` 号气球呢？如果没有别的便利贴贴在它上面，垃圾回收机制（Garbage Collection）会在稍后悄悄把它戳破回收。

### 共享引用：当两个名字指向同一个灵魂

这种机制的深远影响在于：**多个名字可以贴在同一个对象上。**

```python
list_a = [1, 2, 3]
list_b = list_a
```

这并不是把列表复制了一份。这是把 `list_b` 这张新便利贴，贴到了 `list_a` 已经在的那同一个列表对象上。

现在，如果我们修改 `list_a`：

```python
list_a.append(4)
```

我们会发现 `list_b` 也变了：

```python
print(list_b)
# 输出: [1, 2, 3, 4]
```

因为它们本就是同一个东西。

::: info 📝 TS 开发者便签：引用类型
这与 JavaScript/TypeScript 中的 **对象引用 (Object Reference)** 完全一致。  
在 JS 中：  
`const a = { val: 1 }; const b = a;`  
修改 `a.val` 也会影响 `b`。

**区别在于**：在 Python 中，**一切皆对象**。  
哪怕是整数 `int`、浮点数 `float`，在底层也是完整的对象结构（包含引用计数、类型信息等），而不是像 JS 那样存在“原始类型(Primitive)”和“对象(Object)”的二元对立。只是因为 Python 的整数是**不可变**的，所以表现得像值传递。
:::

## 身份与相等：`is` vs `==`

既然名字只是标签，我们就需要区分：

- **相等 (Equality)**：两个气球看起来是不是一样？（上面的字是不是都是 100？）
- **身份 (Identity)**：这是不是同一个气球？

Python 提供了两个操作符：

- **`==`**：检查**值**是否相等（调用对象的 `__eq__` 方法）。
- **`is`**：检查**身份**是否相同（比较内存地址）。

```python
a = [1, 2, 3]
b = [1, 2, 3]  # 创建了一个新的列表，虽然内容一样
c = a           # 贴标签

print(a == b)  # True  （内容一样）
print(a is b)  # False（这是两个不同的气球）

print(a is c)  # True  （同一个气球）
```

::: warning ⚠ 唯一的 None
在 Python 中，**`None` 是一个单例对象**（Singleton）。全宇宙只有一个 `None`。  
因此，判断一个变量是否为空时，**永远**使用 `is`：

```python
# ✅ 正确（最快，最安全）
if user_id is None: ...

# ❌ 不推荐（虽然结果通常也是对的，但如果对象重写了 __eq__ 可能会出事）
if user_id == None: ...
```

:::

## 类型的本质：给便利贴写的说明书

回到 Python 3.12 的现代视角。

既然变量只是便利贴，那么这张便利贴本身是没有类型的。它贴在 `int` 上，它就是 `int` 的引用；贴在 `str` 上，就是 `str` 的引用。这就是**动态类型**的根源。

但是，为了工程的健壮性，我们希望这张便利贴上能多写点信息：**“这张便利贴，只能贴在整数上。”**

这就是 **类型注解 (Type Hints)**。

```python
# 显式声明：age 这张标签，应该只贴在 int 对象上
age: int = 18

# 如果你强行把它贴在字符串上
age = "18岁"
```

**关键点来了：**  
如果你运行上面这行代码，Python 解释器**不会报错**。它会照常运行，把 `age` 贴到字符串 `"18岁"` 上。

为什么？因为 Python 的类型注解是**渐进式**的，是**给人和工具看的**，不是给 CPU 看的。

这就好比你在便利贴上写了“请勿触摸”，但并没有给气球加个玻璃罩。解释器（Runtime）看不懂“请勿触摸”，但你的编辑器（VS Code + Pylance）和检查工具（Ruff/Mypy）能看懂。它们会在你写下 `age = "18岁"` 的那一刻，在编辑器里划出一道显眼的红线，告诉你：_“嘿！你违反了契约！”_

> 💡 **术语说明**：  
> 类型注解（Type Hints）是 Python 3.5 引入的功能（通过 `typing` 模块），并在后续版本中不断增强。它们**不影响程序运行时的行为**，仅用于静态分析工具进行类型检查。

## 现代语法：`type` 关键字（Python 3.12+）

在 Python 3.12 中，定义复杂的类型别名变得异常简单。这让我们在给便利贴写说明书时，可以更加优雅。

```python
# 旧写法 (Python < 3.12)
from typing import List, Union
UserId = Union[int, str]

# ✅ 新写法 (Python 3.12+)
# 使用 type 关键字，配合 | 管道符，这简直就是 TS 的孪生兄弟
type UserID = int | str
type Vector = list[float]

def process(uid: UserID) -> None:
    print(f"Processing {uid}")
```

> 💡 **语法说明**：  
> `type` 是 Python 3.12 新增的关键字，用于定义**类型别名（type alias）**。  
> 它比传统的赋值方式（如 `UserID = int | str`）更清晰，并且支持泛型、嵌套等复杂场景。  
> 注意：`type` 在这里是关键字，不是函数，因此不能加括号或参数。

## 常见误区：`const` 去哪了？

TypeScript 或其他静态语言开发者最常问的问题：“Python 里的 `const` 怎么写？”

答案是：**Python 没有原生的常量关键字。**

我们依然依靠**命名约定**：

```python
# 全大写变量名，暗示这是常量，请不要修改我！
MAX_CONNECTIONS = 100
```

虽然你可以强行修改它，但任何成熟的 Python 工程师看到全大写变量被重新赋值，都会感到不安。

如果你希望获得更强的约束（至少在开发阶段），可以使用 `Final` 类型注解：

```python
from typing import Final

# 告诉类型检查器：这个标签贴上就不能再指向别的对象了
API_KEY: Final[str] = "secret_key"

# 编辑器或类型检查工具（如 mypy）会报错：
# "Cannot assign to final name 'API_KEY'"
# 但 Python 解释器在运行时仍允许赋值（只要你不在乎团队规范）
API_KEY = "new_key"
```

> ⚠️ **注意**：`Final` 仅在静态类型检查时生效，**不会阻止运行时修改**。它是一种“契约式”提示，而非强制保护。

## 🧠 深度思考

> **在 Python 中，字符串是“不可变”的。**
>
> 试着运行以下代码：
>
> ```python
> s = "hello"
> s = s + " world"
> ```
>
> **请问：原来的字符串 `"hello"` 发生了什么变化？变量 `s` 发生了什么变化？**
>
> ::: details 点击查看答案
> **答案：**
>
> 1. **原来的字符串 `"hello"` 没有发生任何变化。** 它依然静静地躺在内存的某个角落里（直到被垃圾回收）。
> 2. **变量 `s` 发生了变化。**
>    - 第一步：创建了一个新的字符串对象 `"hello world"`。
>    - 第二步：撕下便利贴 `s`，从 `"hello"` 上移开，贴到了新的对象 `"hello world"` 上。
>
> 这就是**不可变对象**的含义：你永远无法修改对象本身，你只能让标签指向一个新的对象。
> :::

## 本章小结

名字（变量）是 Python 中最基础的魔法。

1. **心智模型**：变量是**便利贴**，对象是**气球**。
2. **引用**：赋值是贴标签，不是复制内容。
3. **身份**：用 `is` 判断是不是同一个气球，用 `==` 判断长得像不像。
4. **类型**：注解是给工具看的契约，解释器只会温柔地无视它。
5. **常量**：靠命名约定（全大写）和 `Final` 注解表达意图，但无运行时保护。

理解了“名字”的虚幻与“对象”的真实，我们就可以开始谈论如何控制这些对象的命运了。

下一章，我们将面对逻辑的分岔路口。在那里，你将看到 Python 是如何用一种近乎偏执的**“缩进美学”**，来处理复杂的分支逻辑，以及那个让无数新手困惑的 `if` 判断陷阱。
