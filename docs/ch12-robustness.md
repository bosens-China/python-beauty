# ç¬¬ 12 ç« ï¼šé˜²å¾¡æ€§ç¼–ç¨‹ä¸ç±»å‹å®‰å…¨ (Robustness)

> **"The best safety lies in fear."** > **â€œæœ€å¤§çš„å®‰å…¨åœ¨äºæ—¶åˆ»å¿ƒå­˜å¿§æ‚£ã€‚â€**
> â€” _å¨å»‰Â·èå£«æ¯”äºšï¼Œã€Šå“ˆå§†é›·ç‰¹ã€‹ (William Shakespeare, Hamlet)_

---

å†™ç±»å‹æ³¨è§£ä¸ä»…ä»…æ˜¯ä¸ºäº†è®© IDE è¡¥å…¨ï¼Œæ›´æ˜¯ä¸ºäº†åœ¨**ç¼–è¯‘æœŸï¼ˆé™æ€åˆ†ææœŸï¼‰** æ•è·é€»è¾‘æ¼æ´ã€‚

åœ¨ TypeScript ä¸­ï¼Œä½ å¯èƒ½ä¹ æƒ¯äº†ä½¿ç”¨ User-Defined Type Guards (`val is Type`) å’Œ Exhaustiveness Checking (`never`)ã€‚å¥½æ¶ˆæ¯æ˜¯ï¼Œç°ä»£ Python åŒæ ·å…·å¤‡è¿™äº›èƒ½åŠ›ï¼Œè™½ç„¶è¯­æ³•ç•¥æœ‰ä¸åŒï¼Œä½†æ ¸å¿ƒç†å¿µå®Œå…¨ä¸€è‡´ã€‚

## 12.1 è‡ªå®šä¹‰ç±»å‹å®ˆå«ï¼š`TypeGuard`

æˆ‘ä»¬åœ¨ç¬¬ 5 ç« å­¦è¿‡ï¼ŒPython çš„ `isinstance` æ˜¯å¤©ç„¶çš„ç±»å‹å®ˆå«ã€‚
`if isinstance(x, str):` ä¹‹åï¼Œ`x` ä¼šè‡ªåŠ¨è¢«æ”¶çª„ä¸º `str`ã€‚

ä½†å¦‚æœé€»è¾‘æ¯”è¾ƒå¤æ‚å‘¢ï¼Ÿæ¯”å¦‚æ£€æŸ¥ä¸€ä¸ªåˆ—è¡¨æ˜¯å¦**å…¨æ˜¯**å­—ç¬¦ä¸²ï¼Ÿæˆ–è€…æ£€æŸ¥ä¸€ä¸ªå­—å…¸æ˜¯å¦åŒ…å«ç‰¹å®šçš„é”®ï¼Ÿ`isinstance` åšä¸åˆ°è¿™ä¸€ç‚¹ï¼ˆå› ä¸ºæ³›å‹æ“¦é™¤ï¼Œ`isinstance(x, list[str])` æ˜¯éæ³•çš„ï¼‰ã€‚

è¿™æ—¶å€™ä½ éœ€è¦ **`typing.TypeGuard`** (Python 3.10+)ã€‚

```python
from typing import Any, TypeGuard

# å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å› boolï¼Œä½†å‘Šè¯‰é™æ€æ£€æŸ¥å™¨ï¼š
# å¦‚æœè¿”å› Trueï¼Œé‚£ä¹ˆå…¥å‚ val çš„ç±»å‹å°±æ˜¯ list[str]
def is_str_list(val: list[Any]) -> TypeGuard[list[str]]:
    # è¿™é‡Œæ˜¯è¿è¡Œæ—¶çš„æ£€æŸ¥é€»è¾‘
    # æ³¨æ„ï¼šå¿…é¡»ç¡®ä¿è¿è¡Œæ—¶é€»è¾‘å’Œç±»å‹æ³¨è§£ä¸€è‡´ï¼Œå¦åˆ™å°±æ˜¯æ¬ºéª—ç¼–è¯‘å™¨
    return all(isinstance(x, str) for x in val)

def process_items(items: list[Any]):
    # items æ­¤æ—¶æ˜¯ list[Any]

    if is_str_list(items):
        # âœ… åœ¨è¿™ä¸ª block é‡Œï¼ŒIDE ç¡®ä¿¡ items æ˜¯ list[str]
        print(" ".join(items))
    else:
        # âŒ è¿™é‡Œ items ä¾ç„¶æ˜¯ list[Any]
        print("Not a string list")
```

### ğŸ“ TS å¼€å‘è€…ä¾¿ç­¾ï¼š`val is Type`

> - **TS**: `function isStrList(val: any): val is string[] { ... }`
> - **Python**: `def is_str_list(val: Any) -> TypeGuard[list[str]]: ...`
>
> **è­¦ç¤º**ï¼šå°±åƒ TS ä¸€æ ·ï¼Œ`TypeGuard` æ˜¯**å¼€å‘è€…å¯¹ç¼–è¯‘å™¨çš„æ‰¿è¯º**ã€‚å¦‚æœä½ çš„è¿è¡Œæ—¶é€»è¾‘å†™é”™äº†ï¼ˆæ¯”å¦‚å‡½æ•°è¿”å› `True` ä½†åˆ—è¡¨é‡Œæ··è¿›äº†æ•´æ•°ï¼‰ï¼Œé™æ€æ£€æŸ¥å™¨ä¾ç„¶ä¼šç›¸ä¿¡ä½ ï¼Œè¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶å´©æºƒã€‚**èƒ½åŠ›è¶Šå¤§ï¼Œè´£ä»»è¶Šå¤§ã€‚**

## 12.2 ç©·å°½æ€§æ£€æŸ¥ï¼š`assert_never`

è¿™æ˜¯æ„å»ºå¥å£®ç³»ç»Ÿçš„æ€æ‰‹é”ã€‚
å½“ä½ ä½¿ç”¨ `Literal` æˆ– `Enum` å®šä¹‰çŠ¶æ€æ—¶ï¼Œä½ å¸Œæœ›ç¡®ä¿ä»£ç å¤„ç†äº†**æ‰€æœ‰**å¯èƒ½çš„çŠ¶æ€ã€‚å¦‚æœæœªæ¥æœ‰äººåŠ äº†ä¸€ä¸ªæ–°çŠ¶æ€ï¼Œé™æ€æ£€æŸ¥å™¨åº”è¯¥æŠ¥é”™æé†’ã€‚

```python
from typing import Literal, assert_never

type Direction = Literal["left", "right", "up", "down"]

def move(dir: Direction):
    match dir:
        case "left":
            print("Going left")
        case "right":
            print("Going right")
        case "up":
            print("Going up")
        # å‡è®¾æˆ‘ä»¬å¿˜è®°å†™ "down" äº†...

        case _ as unreachable:
            # âŒ é™æ€æ£€æŸ¥æŠ¥é”™ï¼
            # Argument of type "Literal['down']" cannot be assigned to parameter of type "Never"
            assert_never(unreachable)
```

`assert_never` çš„ä½œç”¨æ˜¯å‘Šè¯‰ç±»å‹æ£€æŸ¥å™¨ï¼šâ€œè¿™è¡Œä»£ç æ°¸è¿œä¸åº”è¯¥è¢«æ‰§è¡Œâ€ã€‚å¦‚æœæœ‰æ¼ç½‘ä¹‹é±¼ï¼ˆæ¯”å¦‚ `"down"`ï¼‰æµåˆ°äº†è¿™é‡Œï¼Œå®ƒçš„ç±»å‹å°±ä¸æ˜¯ `Never`ï¼Œä»è€Œè§¦å‘é™æ€é”™è¯¯ã€‚

### ğŸ“ TS å¼€å‘è€…ä¾¿ç­¾ï¼šThe `never` type

> è¿™å®Œå…¨ç­‰åŒäº TS ä¸­çš„ Exhaustiveness Checking æ¨¡å¼ï¼š
>
> ```typescript
> switch (dir) {
>   // ... cases ...
>   default:
>     const _exhaustiveCheck: never = dir; // Error if 'down' is missing
> }
> ```
>
> Python 3.11+ çš„ `assert_never` è®©è¿™ä¸€æ¨¡å¼å˜å¾—æ ‡å‡†åŒ–äº†ã€‚

## 12.3 é”™è¯¯å¤„ç†å“²å­¦ï¼šå¼‚å¸¸ vs Result æ¨¡å¼

Python çš„ä¼ ç»Ÿå“²å­¦æ˜¯ **EAFP**ï¼ˆæŠ›å‡ºå¼‚å¸¸ï¼‰ã€‚ä½†å¼‚å¸¸æœ‰ä¸€ä¸ªè‡´å‘½å¼±ç‚¹ï¼š**å®ƒæ˜¯éšå¼çš„**ã€‚å‡½æ•°ç­¾åé‡Œçœ‹ä¸åˆ°å®ƒä¼šæŠ›å‡ºä»€ä¹ˆå¼‚å¸¸ã€‚

åœ¨è¿½æ±‚é«˜å¯é æ€§çš„ä»£ç ä¸­ï¼ˆæˆ–è€…å— Rust/Go/FP å½±å“çš„ TS å¼€å‘è€…ï¼‰ï¼Œæˆ‘ä»¬å€¾å‘äºæŠŠé”™è¯¯**æ˜¾å¼åŒ–**ã€‚

### æ–¹å¼ä¸€ï¼šè”åˆç±»å‹è¿”å› (Union Return)

è¿™æ˜¯æœ€ç®€å•çš„ Result æ¨¡å¼æ›¿ä»£å“ï¼Œåˆ©ç”¨ Python çš„è”åˆç±»å‹ã€‚

```python
from dataclasses import dataclass

@dataclass
class Success[T]:
    value: T

@dataclass
class Error:
    message: str

# æ˜¾å¼å£°æ˜ï¼šä½ è¦ä¹ˆå¾—åˆ°æˆåŠŸçš„ç»“æœï¼Œè¦ä¹ˆå¾—åˆ°é”™è¯¯å¯¹è±¡
def parse_int(s: str) -> Success[int] | Error:
    if s.isdigit():
        return Success(int(s))
    return Error("Not a number")

# è°ƒç”¨æ–¹å¿…é¡»æ˜¾å¼å¤„ç†é”™è¯¯ï¼Œå¦åˆ™ç±»å‹æ£€æŸ¥é€šä¸è¿‡ï¼ˆæ¯”å¦‚æ— æ³•è®¿é—® valueï¼‰
result = parse_int("123")

match result:
    case Success(val):
        print(val * 2)
    case Error(msg):
        print(f"Failed: {msg}")
```

### æ–¹å¼äºŒï¼šä½¿ç”¨ç¬¬ä¸‰æ–¹åº“

å¦‚æœä½ å–œæ¬¢ TS çš„ `fp-ts` æˆ– Rust çš„ `Result<T, E>`ï¼Œå¯ä»¥ä½¿ç”¨ Python çš„ç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚ `returns`ï¼‰ï¼Œå®ƒæä¾›äº† `.map()`, `.bind()` ç­‰ Monad æ“ä½œã€‚

**å»ºè®®**ï¼šåœ¨ Python ä¸­ï¼Œ**ä¸è¦è¿‡åº¦ä½¿ç”¨ Result æ¨¡å¼**ã€‚

- å¯¹äº**ç³»ç»Ÿçº§é”™è¯¯**ï¼ˆç½‘ç»œæ–­è¿ã€æ–‡ä»¶ä¸å­˜åœ¨ï¼‰ï¼Œä½¿ç”¨ Python åŸç”Ÿçš„ Exceptionã€‚
- å¯¹äº**ä¸šåŠ¡çº§é”™è¯¯**ï¼ˆç”¨æˆ·ä¸å­˜åœ¨ã€ä½™é¢ä¸è¶³ï¼‰ï¼Œä½¿ç”¨ Union Return æˆ–è‡ªå®šä¹‰ Exceptionã€‚è¿‡åº¦å°è£… Result ä¼šè®©ä»£ç å˜å¾—é Pythonicã€‚

## 12.4 å¿ƒæ™ºæ¨¡å‹ï¼š`Optional` çš„æ»¥ç”¨

`None` (å³ TS çš„ `null`) æ˜¯ä»¥åäº¿ç¾å…ƒè®¡çš„é”™è¯¯ã€‚
å¾ˆå¤š Python æ–°æ‰‹ä¹ æƒ¯è¿™æ ·å†™ä»£ç ï¼š

```python
# âŒ ä¸å¥½çš„ä¹ æƒ¯ï¼šæ»¥ç”¨ Optional
class User:
    def __init__(self):
        # å…ˆåˆå§‹åŒ–ä¸º Noneï¼Œç„¶åå†æ‰¾æœºä¼šèµ‹å€¼
        self.name: str | None = None

    def set_name(self, name: str):
        self.name = name

def process(u: User):
    # æ¯æ¬¡ä½¿ç”¨éƒ½è¦åˆ¤æ–­ï¼Œä¸ä»…çƒ¦ï¼Œè€Œä¸”å®¹æ˜“æ¼
    if u.name is not None:
        print(u.name.upper())
```

è¿™ç§â€œå…ˆåˆ›å»ºç©ºå¯¹è±¡ï¼Œå†å¡«å€¼â€çš„æ¨¡å¼ä¼šå¯¼è‡´ `None` åœ¨ç³»ç»Ÿä¸­åƒç—…æ¯’ä¸€æ ·ä¼ æ’­ã€‚ä½ æ°¸è¿œä¸çŸ¥é“ä¸€ä¸ª User å¯¹è±¡åˆ°åº•æ˜¯â€œåˆå§‹åŒ–äº†ä¸€åŠâ€è¿˜æ˜¯â€œå®Œæ•´â€çš„ã€‚

**é˜²å¾¡æ€§å»ºè®®**ï¼š

1.  **æ„é€ å³å®Œå¤‡**ï¼šå¯¹è±¡åœ¨ `__init__` åå¿…é¡»æ˜¯å®Œæ•´å¯ç”¨çš„ã€‚
2.  **è¾¹ç•Œéš”ç¦»**ï¼šå¦‚æœæ•°æ®å¯èƒ½ç¼ºå¤±ï¼ˆæ¯”å¦‚ DB æŸ¥è¯¢ç»“æœï¼‰ï¼Œåœ¨ Controller å±‚å¤„ç†å®Œ `None`ï¼Œä¼ ç»™ Service/Domain å±‚çš„æ•°æ®åº”å½“æ˜¯ç¡®å®šçš„ï¼ˆNon-Optionalï¼‰ã€‚
3.  **ä½¿ç”¨å“¨å…µ (Sentinel)**ï¼šæœ‰æ—¶å€™ `None` æ˜¯æœ‰æ•ˆå€¼ï¼Œä½ éœ€è¦åŒºåˆ†â€œæœªä¼ å‚â€å’Œâ€œä¼ äº† Noneâ€ã€‚

```python
# åˆ›å»ºä¸€ä¸ªå”¯ä¸€çš„å¯¹è±¡ä½œä¸ºå“¨å…µ
MISSING = object()

def update(val: Any = MISSING):
    if val is MISSING:
        print("No value provided")
    elif val is None:
        print("Value is None")
    else:
        print(f"Value is {val}")
```

---

**æœ¬ç« å°ç»“**

é˜²å¾¡æ€§ç¼–ç¨‹ä¸ä»…ä»…æ˜¯å†™ `try...except`ï¼Œè€Œæ˜¯åˆ©ç”¨ç±»å‹ç³»ç»Ÿæ„å»ºâ€œç¼–è¯‘æœŸé˜²ç«å¢™â€ã€‚

1.  **TypeGuard**: è®©ä½ ç¼–å†™è‡ªå®šä¹‰çš„ç±»å‹æ”¶çª„é€»è¾‘ï¼Œå¤„ç†å¤æ‚æ•°æ®ç»“æ„ã€‚
2.  **assert_never**: ç¡®ä¿ä½ çš„ä¸šåŠ¡é€»è¾‘å¤„ç†äº†æ‰€æœ‰å¯èƒ½çš„åˆ†æ”¯ï¼ˆæšä¸¾/è”åˆç±»å‹ï¼‰ã€‚
3.  **Result vs Exception**: åœ¨æ˜¾å¼é”™è¯¯å¤„ç†å’Œ Pythonic é£æ ¼ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ã€‚
4.  **No Optional**: å°½é‡é¿å…è®© `None` è¿›å…¥ä½ çš„æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼Œåœ¨è¾¹ç•Œå¤„æ¶ˆç­å®ƒã€‚

æŒæ¡äº†è¿™äº›ï¼Œä½ å†™çš„ Python ä»£ç å°†ä¸å†æ˜¯è„†å¼±çš„è„šæœ¬ï¼Œè€Œæ˜¯åšå›ºçš„å·¥ç¨‹ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å›åˆ° Python çš„å…ƒç¼–ç¨‹é¢†åŸŸï¼Œæ¢è®¨**è£…é¥°å™¨**ã€‚ä½†è¿™æ¬¡ï¼Œæˆ‘ä»¬å°†åº”ç”¨æœ¬ç« å­¦åˆ°çš„é˜²å¾¡æ€§æ€ç»´ï¼Œå­¦ä¹ å¦‚ä½•ç¼–å†™**ä¸ä¸¢å¤±ç±»å‹ä¿¡æ¯**çš„è£…é¥°å™¨ã€‚è¿™æ˜¯è®¸å¤š Python é«˜çº§åº“ï¼ˆå¦‚ FastAPI, Celeryï¼‰çš„åº•å±‚ç§˜å¯†ã€‚

> **æ€è€ƒé¢˜**ï¼š
> å¦‚æœæˆ‘æœ‰ `def fetch() -> list[User] | None`ï¼Œæ¯æ¬¡è°ƒç”¨éƒ½è¦æ£€æŸ¥ `if result is not None` å¾ˆéº»çƒ¦ã€‚
> åœ¨ TS ä¸­ä½ å¯ä»¥å†™ä¸€ä¸ª `assert(result)` å‡½æ•°æ–­è¨€å®ƒä¸ä¸ºç©ºã€‚åœ¨ Python ä¸­ï¼Œä½ èƒ½ç”¨ `TypeGuard` å†™ä¸€ä¸ªç±»ä¼¼çš„ `assert_not_none(val)` å—ï¼Ÿå®ƒèƒ½æ”¹å˜è°ƒç”¨æ–¹å˜é‡çš„ç±»å‹å—ï¼Ÿ
